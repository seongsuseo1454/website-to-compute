name: AI PR Copilot

on:
  workflow_dispatch:
    inputs:
      prompt:
        description: "AI에게 시킬 작업 지시문"
        required: true
      fileGlobs:
        description: "수정/생성 대상 파일 글롭(예: public/**/*.html,src/**/*.ts)"
        required: false
        default: ""
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write

jobs:
  run-ai-editor:
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, '/ai-pr'))
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install deps
        run: |
          npm init -y >/dev/null 2>&1 || true
          npm i openai@4 octokit@4 fast-glob@3 js-yaml@4

      - name: Write AI editor script
        run: |
          mkdir -p tools
          cat > tools/ai-editor.mjs <<'EOF'
          import fs from 'node:fs';
          import path from 'node:path';
          import glob from 'fast-glob';
          import { Octokit } from 'octokit';
          import YAML from 'js-yaml';

          // ===== Config =====
          const MAX_FILES = 40;          // 한 번에 수정 허용 파일 수
          const DEFAULT_GLOBS = ['**/*', '!node_modules/**', '!.git/**', '!**/*.lock'];
          const BRANCH_PREFIX = 'ai-edit/';
          const COMMIT_PREFIX = 'AI: ';
          const MODEL = process.env.OPENAI_MODEL || 'gpt-4.1-mini'; // 원하시는 모델명
          const REPO = process.env.GITHUB_REPOSITORY; // owner/repo
          const [owner, repo] = REPO.split('/');

          // ===== Helpers =====
          const readText = (p) => fs.readFileSync(p, 'utf8');
          const writeText = (p, c) => fs.writeFileSync(p, c);
          const ensureDir = (p) => fs.mkdirSync(path.dirname(p), { recursive: true });

          // 간단한 브랜치명
          const nowTag = new Date().toISOString().replace(/[:.]/g,'-');
          const branchName = BRANCH_PREFIX + nowTag;

          const inputPrompt = process.env.AI_PROMPT;         // 지시문
          const fileGlobs = (process.env.FILE_GLOBS || '').trim();
          const includeGlobs = fileGlobs ? fileGlobs.split(',').map(s=>s.trim()) : DEFAULT_GLOBS;

          // ===== OpenAI =====
          import OpenAI from "openai";
          const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

          // 레포 파일 스냅샷 만들기 (요약)
          function buildRepoContext(fileList) {
            const preview = fileList.slice(0, 100).map(f => `- ${f}`).join('\n');
            return `Repository file list (first ${Math.min(fileList.length,100)} shown of ${fileList.length}):
${preview}`;
          }

          // LLM에게 "수정 계획 + 패치" 생성 요청
          async function askLLM(context, instruction) {
            const sys = `You are an expert repository editor.
Return a YAML describing file edits in this structure:

edits:
  - file: "relative/path.ext"
    action: "create|update|delete"
    rationale: "why"
    content: |
      (full file content AFTER edit; omit for delete)

Rules:
- Only include files that you want to create/update/delete (max ${MAX_FILES}).
- Always output VALID YAML only. No backticks. No extra prose.
- For updates, return FULL final content (not a diff).
- Keep build passing and avoid breaking imports.`;

            const user = `${context}

=== INSTRUCTION ===
${instruction}`;

            const res = await openai.chat.completions.create({
              model: MODEL,
              messages: [
                { role: 'system', content: sys },
                { role: 'user', content: user }
              ],
              temperature: 0.2,
            });

            return res.choices[0].message.content;
          }

          // YAML 파싱 → 실제 파일 반영
          function applyEdits(yamlText) {
            const doc = YAML.load(yamlText);
            if (!doc || !Array.isArray(doc.edits)) throw new Error('Invalid YAML: missing edits');
            if (doc.edits.length > MAX_FILES) throw new Error('Too many file edits requested');

            const summary = [];
            for (const e of doc.edits) {
              if (!e.file || !e.action) throw new Error('Edit item missing file/action');
              const target = path.normalize(e.file);
              if (e.action === 'delete') {
                if (fs.existsSync(target)) fs.rmSync(target, { force:true });
                summary.push(`DELETE ${target}`);
              } else if (e.action === 'create' || e.action === 'update') {
                if (typeof e.content !== 'string') throw new Error(`Edit for ${target} missing content`);
                ensureDir(target);
                writeText(target, e.content);
                summary.push(`${fs.existsSync(target) ? 'UPDATE' : 'CREATE'} ${target}`);
              } else {
                throw new Error(`Unknown action ${e.action}`);
              }
            }
            return summary;
          }

          // 깃 커밋/PR
          async function gitCommitAndPR(summary) {
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN || process.env.GH_TOKEN });

            // 기본 브랜치 확인
            const { data: repoData } = await octokit.rest.repos.get({ owner, repo });
            const base = repoData.default_branch;

            // 최신 SHA
            const { data: baseRef } = await octokit.rest.git.getRef({
              owner, repo, ref: `heads/${base}`
            });

            // 새 브랜치 생성
            await octokit.rest.git.createRef({
              owner, repo,
              ref: `refs/heads/${branchName}`,
              sha: baseRef.object.sha
            });

            // 변경 파일 스테이징 → 커밋
            // (여기선 Git CLI 대신 GitHub Contents API를 사용)
            for (const filePath of summary.map(s => s.split(' ').pop())) {
              if (!filePath) continue;
              const isDelete = summary.find(s => s.endsWith(filePath))?.startsWith('DELETE');
              if (isDelete) {
                // 삭제 커밋
                // 파일 sha 필요 → 있으면 삭제
                try {
                  const { data: fileData } = await octokit.rest.repos.getContent({
                    owner, repo, path: filePath, ref: branchName
                  });
                  const sha = Array.isArray(fileData) ? null : fileData.sha;
                  if (sha) {
                    await octokit.rest.repos.deleteFile({
                      owner, repo, path: filePath, message: COMMIT_PREFIX + `delete ${filePath}`,
                      sha, branch: branchName
                    });
                  }
                } catch(_) { /* 파일 없으면 무시 */ }
              } else {
                // 생성/수정 커밋
                const content = fs.readFileSync(filePath);
                const existing = await octokit.rest.repos.getContent
                  .catch(()=>({ data:null }))({ owner, repo, path: filePath, ref: branchName });

                const sha = existing?.data && !Array.isArray(existing.data) ? existing.data.sha : undefined;

                await octokit.rest.repos.createOrUpdateFileContents({
                  owner, repo,
                  path: filePath,
                  message: COMMIT_PREFIX + `update ${filePath}`,
                  content: content.toString('base64'),
                  sha,
                  branch: branchName
                });
              }
            }

            // PR 생성
            const title = `${COMMIT_PREFIX}${new Date().toLocaleString()} – ${summary.length} file(s)`;
            const body = `This PR was generated by AI.\n\n**Summary**\n\`\`\`\n${summary.join('\n')}\n\`\`\``;

            const { data: pr } = await octokit.rest.pulls.create({
              owner, repo, title, head: branchName, base, body
            });

            console.log(`PR #${pr.number} created: ${pr.html_url}`);
          }

          // ===== Main =====
          (async () => {
            if (!inputPrompt) throw new Error('AI_PROMPT is empty.');
            const files = await glob(includeGlobs, { dot: true });
            const context = buildRepoContext(files);

            const planYaml = await askLLM(context, inputPrompt);
            const summary = applyEdits(planYaml);
            console.log('Applied edits:\n' + summary.join('\n'));

            await gitCommitAndPR(summary);
          })().catch(err => {
            console.error(err);
            process.exit(1);
          });
          EOF

      - name: Run (workflow_dispatch)
        if: github.event_name == 'workflow_dispatch'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AI_PROMPT: ${{ github.event.inputs.prompt }}
          FILE_GLOBS: ${{ github.event.inputs.fileGlobs }}
        run: node tools/ai-editor.mjs

      - name: Run (issue_comment)
        if: github.event_name == 'issue_comment'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AI_PROMPT: ${{ github.event.comment.body }}
          FILE_GLOBS: ""
        run: |
          # 코멘트 본문에서 "/ai-pr" 이후 텍스트만 추출
          TXT="${AI_PROMPT#*/ai-pr }"
          [ -z "$TXT" ] && echo "No instruction after /ai-pr" && exit 1
          AI_PROMPT="$TXT" node tools/ai-editor.mjs
